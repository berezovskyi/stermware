\title{STermWare: brief semantics description}
\author{
        Ruslan Shevchenko \\
                ruslan@shevchenko.kiev.ua\\
        Kiev, Ukraine
}
\date{\today}



\documentclass[12pt]{article}
\usepackage{listings}
\usepackage{amsmath}

% "define" Scala
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}



\begin{document}
\maketitle

\begin{abstract}
 Termware is a term rewriting system which implemented as internal and external DSL.
\end{abstract}

\section{Motivation}

  Rule-based deduction and rewriting is a well known techniques. Exists many formalizations, from
  equational logic to $\rho$-caclulus \cite{RhoCal-Wrla2002} and pure pattern calculus\cite{Jay05purepattern}   Few programming languages are build
  with 


  We need compact and clean formalizm for definition of programming language construction. Classical term
 rewriting can be used for describing program transformations 'in small', but leave dealing with context out 
 of scope of analythis. Exists different approaches for solving such issues: program analyzers based on 
 termware framework \cite{DBLP:journals/fuin/DoroshenkoS06} uses terms enriched by context parameters wich provide
 API for quering semantics properties, Statego\cite{BravenboerKVV08} use dynamic context-specific rules.
  
  


\section{Basic definitions}

   Let's build term algebra on top of some set of constants, which constists from
\begin{itemize}
 \item original constants ${c_i} \in C$ Also we
 will need to distinguish some special subset of constants: atoms ${a_i}$
 \item functional term $f_i \in F$  i.e. if $f \in F, c_i \in T (i \in 1..n)$, then $f(c_{1} \dots c_{n}) \in T$
 \item variable terms $x_{i}$ which can be inside variable-bound terms.
 \item variable bounds term, i.e. so-called 'with-expressions': $with(x_1 \to t_i,\dots x_n\to t_n):t$
 \item rule terms, i. e. so-called 'rule expressions': 
       $rule(p_1 \to r_1; p_2 \to r_2 ; \dots p_n \to r_n : p_{fail})$
 \item application $a b$
\end{itemize}

  Transformations:

\begin{itemize}
     \item application reduction
           $$ rule(with(x_i\to x_i):p_i \to r_i, ... ) q = 
                    \left\{\begin{array}{l l}
                             \sigma r_i & \text{if $\sigma=\text{unify}(p_i,q)/x_{i}$} \\
                             p_{fail}   & otherwise \\
                           \end{array}
                    \right\} 
           $$
     \item with propagation
           $$ with(x):rule(p_1 \dots p_{n}, p_{fail}) =
               rule(with(x,p_1) \dots with(x,p_{n}), with(p_{fail})) =
           $$
     \item with chaining
           $$ with(x_1 \dots x_n):with(y_1 \dots y_n):p =
                with(x_1 \dots x_n, y_1 \dots y_n):p $$
     \item with variable elimination
           $$ with(x_{1} \dots x_{i} \dots x_{n}):p = 
              with(x_{1} \dots x_{i-1}, x_{i+1}, \dots x_{n})p \; if x_i \not\in p $$  
\end{itemize}




\bibliographystyle{abbrv}
\bibliography{stermware}

\end{document}
